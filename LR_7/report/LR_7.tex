\documentclass[a4paper,12pt]{report}
\usepackage{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{amsmath}
\geometry{top=2cm}
\usepackage{titlesec}
\usepackage{color}
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

% Для листинга кода:
\lstset{ %
language=C++,                 % выбор языка для подсветки
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=-5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,
backgroundcolor=\color{white},         
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)},   % если нужно добавить комментарии в коде
	    keywordstyle=\color{blue}\ttfamily,
	    stringstyle=\color{red}\ttfamily,
	    commentstyle=\color{orange}\ttfamily,
	    morecomment=[l][\color{magenta}]{\#},
	    columns=fullflexible   % если нужно добавить комментарии в коде
}

% Для измененных титулов глав:
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

\begin{filecontents}{Standart.dat}
1000 0.09748
2000 0.16453
3000 0.24387
4000 0.30328
5000 0.4103
6000 0.4761
7000 0.51321
8000 0.54418
9000 0.60875
10000 0.73986
11000 0.71644
12000 0.75093
13000 0.80933
14000 0.86098
15000 0.84306
16000 0.87117
17000 0.98047
18000 0.8834
19000 1.05488
20000 1.085
21000 1.16387
22000 1.1409
23000 1.14672
24000 1.14971
25000 1.29421
26000 1.18106
27000 1.11985
28000 1.09025
29000 1.28982
30000 1.1547
31000 1.1665
32000 1.1232
33000 1.18683
34000 1.35493
35000 1.28121
36000 1.38967
37000 1.40635
38000 1.19105
39000 1.39859
40000 1.4439
41000 1.46937
42000 1.53102
43000 1.35639
44000 1.39363
45000 1.34017
46000 1.32861
47000 1.52501
48000 1.28076
49000 1.23893
50000 1.32852
51000 1.31072
52000 1.55206
53000 1.45569
54000 1.65323
55000 1.41101
56000 1.5504
57000 1.57145
58000 1.58771
59000 1.20009
60000 1.22528
61000 1.47834
62000 1.33383
63000 1.55281
64000 1.60478
65000 1.42802
66000 1.49227
67000 1.53958
68000 1.49006
69000 1.84484
70000 1.76316
71000 1.45637
72000 1.62055
73000 1.56283
74000 1.9554
75000 1.70318
76000 2.61414
77000 3.11052
78000 3.2023
79000 2.63
80000 2.62766
81000 2.70751
82000 2.78599
83000 2.92057
84000 3.0364
85000 2.85583
86000 3.27821
87000 2.85545
88000 2.79024
89000 2.87395
90000 2.537
91000 3.4615
92000 3.00771
93000 2.95005
94000 3.19143
95000 3.19006
96000 2.80877
97000 2.74994
98000 3.43017
99000 3.09234
100000 3.39885
\end{filecontents}

\begin{filecontents}{KMP.dat}
1000 0.11911
2000 0.23615
3000 0.3428
4000 0.44624
5000 0.53576
6000 0.62826
7000 0.69621
8000 0.78329
9000 0.85345
10000 0.96117
11000 1.02498
12000 1.0636
13000 1.14981
14000 1.1588
15000 1.19599
16000 1.27665
17000 1.37665
18000 1.54124
19000 1.67858
20000 1.95758
21000 1.8353
22000 1.55502
23000 1.70979
24000 1.72133
25000 1.48051
26000 1.62365
27000 1.84147
28000 1.93803
29000 1.89708
30000 1.80414
31000 1.85734
32000 1.89822
33000 1.82361
34000 1.87259
35000 1.6948
36000 1.96574
37000 1.70486
38000 2.00184
39000 1.72943
40000 1.86337
41000 1.86924
42000 2.01882
43000 1.82306
44000 2.07062
45000 2.07285
46000 1.81739
47000 1.98407
48000 1.82798
49000 2.09926
50000 1.99581
51000 2.05635
52000 2.27748
53000 2.33395
54000 2.01058
55000 1.8791
56000 2.11428
57000 1.85716
58000 1.96195
59000 2.00111
60000 2.09698
61000 1.90139
62000 1.75287
63000 1.92661
64000 2.10928
65000 1.81245
66000 2.40746
67000 2.37501
68000 2.02757
69000 1.94998
70000 1.8824
71000 2.0542
72000 2.32661
73000 2.28241
74000 2.1557
75000 2.30029
76000 2.05561
77000 1.98643
78000 2.06879
79000 2.45553
80000 2.11531
81000 2.35168
82000 1.8774
83000 1.85141
84000 1.8692
85000 1.89233
86000 2.86727
87000 1.75793
88000 2.26533
89000 2.20764
90000 1.83888
91000 2.17461
92000 2.10352
93000 1.91751
94000 2.14431
95000 1.56787
96000 2.12942
97000 2.40677
98000 1.9696
99000 1.93244
100000 2.35018
\end{filecontents}

\begin{filecontents}{BM.dat}
1000 0.05021
2000 0.10333
3000 0.14246
4000 0.18386
5000 0.2304
6000 0.25049
7000 0.28613
8000 0.32614
9000 0.33745
10000 0.38333
11000 0.38763
12000 0.41845
13000 0.4454
14000 0.46104
15000 0.52108
16000 0.59617
17000 0.58226
18000 0.54897
19000 0.67526
20000 0.60974
21000 0.59641
22000 0.58538
23000 0.58578
24000 0.65109
25000 0.62176
26000 0.60788
27000 0.68945
28000 0.73583
29000 0.72946
30000 0.68067
31000 0.79123
32000 0.81923
33000 0.74915
34000 0.71016
35000 0.79035
36000 0.69165
37000 0.72152
38000 0.7604
39000 0.80432
40000 0.7974
41000 0.82408
42000 0.76277
43000 0.83605
44000 0.74682
45000 0.62926
46000 0.76459
47000 0.84771
48000 0.8617
49000 0.83173
50000 0.75165
51000 0.90671
52000 0.68973
53000 0.63738
54000 0.79733
55000 0.94159
56000 0.98736
57000 0.85572
58000 0.76616
59000 0.90803
60000 0.77089
61000 0.79591
62000 0.90989
63000 0.77444
64000 1.07251
65000 0.78637
66000 0.87735
67000 0.96987
68000 0.73454
69000 0.81175
70000 0.8282
71000 0.9925
72000 0.96211
73000 0.81362
74000 0.87648
75000 0.90177
76000 0.9821
77000 1.03366
78000 0.83104
79000 0.72252
80000 0.83278
81000 0.93452
82000 0.79165
83000 0.97315
84000 1.03412
85000 1.02488
86000 1.05573
87000 0.81953
88000 0.87096
89000 0.94958
90000 0.68594
91000 0.83203
92000 0.97121
93000 0.82933
94000 0.93421
95000 0.94097
96000 0.96306
97000 0.90675
98000 1.04509
99000 0.85769
100000 0.94807
\end{filecontents}

\begin{document}
\begin{titlepage}
	\centering
	{\scshape\LARGE МГТУ им. Н.Э.Баумана \par}
	\vspace{4cm}
	{\scshape\Large Лабораторная работа №7\par}
	\vspace{0.5cm}	
	{\scshape\Large По курсу: "Анализ алгоритмов"\par}
	\vspace{2cm}
	{\huge\bfseries Поиск подстроки в строке\par}
	\vspace{3cm}
	\Large Работу выполнил: Луговой Дмитрий, ИУ7-51Б\par
	\vspace{0.5cm}
	\Large Преподаватель:  Волкова Л.Л.\par

	\vfill
	\large \textit {Москва, 2019} \par
\end{titlepage}

\setcounter{page}{2}

\tableofcontents

\newpage
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}
\hspace{0.6cm}  \textbf{Поиск подстроки в строке}— одна из простейших задач поиска информации. Применяется в виде встроенной функции в текстовых редакторах, СУБД, поисковых машинах, языках программирования и т. п.\\

\textbf{Цель работы}: изучение алгоритмов поиска подстроки в строке.\\\\

\textbf{\LARGE Задачи работы}\\\\
Задачами данной лабораторной являются:
\begin{enumerate}
\item Изучить алгоритмы основные алгоритмы поиска подстроки в строке;
\item Реализовать эти алгоритмы;
\item Провести сравнительный анализ алгоритмов.
\end{enumerate}

\chapter{Аналитическая часть}
\hspace{0.6cm}В данном разделе содержится описание задачи поиска подстроки в строке и алгоритмы для её решения.
\section{Задача поиска подстроки}

\hspace{0.6cm}Поиск подстроки в строке— класс алгоритмов над строками, которые позволяют найти паттерн в тексте. Пусть есть некоторый текст Т и слово  W. Необходимо найти первое вхождение этого слова в указанном тексте. Это действие типично для любых систем обработки текстов. (Элементы массивов Т и W – символы некоторого конечного алфавита – например, ${0, 1}$, или ${a, …, z}$, или ${а, …, я}$.)

Наиболее типичным приложением такой задачи является документальный поиск: задан фонд документов, состоящих из последовательности библиографических ссылок, каждая ссылка сопровождается «дескриптором», указывающим тему соответствующей ссылки. Надо найти некоторые ключевые слова, встречающиеся среди дескрипторов. 

На сегодняшний день существует огромное разнообразие алгоритмов поиска подстроки. Программисту приходится выбирать подходящий в зависимости от таких факторов: длина строки, в которой происходит поиск, необходимость оптимизации, размер алфавита, возможность проиндексировать текст, требуется ли одновременный поиск нескольких строк.  В данной лабораторной работе рассмотрены основные алгоритмы сравнения с образцом:
\begin{itemize}
\item Стандартный алгоритм;
\item Алгоритм Кнута-Морриса-Пратта;
\item Алгоритм Бойера-Мура.
\end{itemize}

\subsection{Стандартный алгоритм}
\hspace{0.6cm}Стандартный алгоритм начинается со сравнения первого символа текста с первым символом подстроки. Если они совпадают, то происходит переход ко второму символу текста и подстроки. При совпадении сравниваются следующие символы. Так продолжается до тех пор, пока не окажется, что подстрока целиком совпала с отрезком текста, или пока не встретятся несовпадающие символы. В первом случае задача решена, во втором указатель текущего положения сдвигается в тексте на один символ и заново начинается сравнение с подстрокой.

\subsection{Алгоритм Кнута-Морриса-Пратта}
\hspace{0.6cm}Алгоритм Кнута-Морриса-Пратта основан на принципе конечного автомата, однако он использует более простой метод обработки неподходящих символов. В этом алгоритме состояния помечаются символами, совпадение с которыми должно в данный момент произойти. Из каждого состояния имеется два перехода: один соответствует успешному сравнению, другой - несовпадению. Успешное сравнение означает переход в следующий узел автомата, а в несовпадения - попадание в предыдущий узел, отвечающий образцу. 
В программной реализации этого алгоритма применяется массив сдвигов, создающийся для каждой подстроки, которая ищется в тексте. Для каждого символа из подстроки рассчитывается значение, равное максимальной длине совпадающего префикса и суффикса отеосительно конкретного элемента подстроки. Создание этого массива позволяет при несовпадении строки сдвигать ее на расстояние, большее, чем 1 (в отличие от стандартного алгоритма).

\subsection{Алгоритм Бойера-Мура}
\hspace{0.6cm}Алгоритм Бойера-Мура осуществляет сравнение с образцом справа налево, а не слева направо. Исследуя искомый образец, можно осуществлять более эффективные прыжки в тексте при обнаружении несовпадения. В этом алгоритме кроме таблицы суффиксов применяется таблица стоп-символов. Она заполняется для каждого символа в подстроке. Для каждого встречающегося в подстроке символа таблица заполняется по принципу максимальной позиции символа в строке, за исключением последнего символа. При определении сдвига при очередном несовпадении строк, выбирается максимальное значение из таблицы суффиксов и стоп-символов.

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
В данном разделе была рассмотрена задача поиска в подстроке, а также выделены основные алгоритмы ее решения - стандартный алгоритм, алгоритм Кнута-Морриса-Пратта и алгоритм Бойера-Мура.

\chapter{Конструкторская часть}

В данном разделе рассмотрены пошаговые примеры выполнения алгоритмов поиска подстроки в строке.

\section{Пример работы алгоритмов}
Пусть
\begin{itemize}
\item string = "ababacabaa" - исходная строка;
\item substring = "abaa" - искомая подстрока.
\end{itemize} 

\subsection{Стандартный}

\hspace{0.6cm}Стандартный алгоритм сравнивает подстроку и строку посимвольно, и начинает все сравнение заново, если хоть 1 символ не совпал.
Результат его работы продемонстрирован в таблице 2.1.

\begin{table}[ht!]
\begin{center}
\caption{Пошаговая работа стандартного алгоритма}
\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
	\hline
	a&b&a&b&a&c&a&b&a&a \\
	\hline
	\hline
	\textcolor{green}{a}&\textcolor{green}{b}&\textcolor{green}{a}&\textcolor{red}{a}&&&&&&\\
	\hline
	&\textcolor{red}{a}&b&a&a&&&&&\\
	\hline
	&&\textcolor{green}{a}&\textcolor{green}{b}&\textcolor{green}{a}&\textcolor{red}{a}&&&&\\
	\hline
	&&&\textcolor{red}{a}&b&a&a&&&\\
	\hline
	&&&&\textcolor{green}{a}&\textcolor{red}{b}&a&a&&\\
	\hline
	&&&&&\textcolor{red}{a}&b&a&a&\\
	\hline
	&&&&&&\textcolor{green}{a}&\textcolor{green}{b}&\textcolor{green}{a}&\textcolor{green}{a}\\
	\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Алгоритм Кнута-Морриса-Пратта}

\hspace{0.6cm}Для алгоритма Кнута-Морриса-Пратта вычисленный массив префиксов для заданой подстроки substring имеет вид [0, 0, 1, 1].

Таблица 2.2 отображает пошаговую работу алгоритма Кнута-Морриса-Пратта при данном массиве префиксов.

\begin{table}[ht!]
\begin{center}
\caption{Пошаговая работа алгоритма Кнута-Морриса-Пратта}
\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
	\hline
	a&b&a&b&a&c&a&b&a&a \\
	\hline
	\hline
	\textcolor{green}{a}&\textcolor{green}{b}&\textcolor{green}{a}&\textcolor{red}{a}&&&&&&\\
	\hline
	&&a&b&\textcolor{green}{a}&\textcolor{red}{a}&&&&\\
	\hline
	&&&&\textcolor{green}{a}&\textcolor{red}{b}&a&a&&\\
	\hline
	&&&&&\textcolor{red}{a}&b&a&a&\\
	\hline
	&&&&&&\textcolor{green}{a}&\textcolor{green}{b}&\textcolor{green}{a}&\textcolor{green}{a}\\
	\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Алгоритм Бойера-Мура}

\hspace{0.6cm}Для алгоритма Бойера-Мура вычисленный массив суффиксов для заданой подстроки subsrting имеет значение: [2, 5, 5, 6].

Переходы алфавита для подстроки sub:  ['a' = 0, 'b' = 2]. Если буквы нет в подстроке, то считается, что переход равен длине подстроки.

Таблица 2.3 показывает пошаговую работу алгоритма Бойера-Мура для приведенных массивов суффиксов и стоп-символов.

\begin{table}[ht!]
\begin{center}
\caption{Пошаговая работа алгоритма Бойера-Мура}
\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
	\hline
	a&b&a&b&a&c&a&b&a&a \\
	\hline
	\hline
	a&b&a&\textcolor{red}{a}&&&&&&\\
	\hline
	&&a&b&a&\textcolor{red}{a}&&&&\\
	\hline
	&&&&&&\textcolor{green}{a}&\textcolor{green}{b}&\textcolor{green}{a}&\textcolor{green}{a}\\
	\hline
\end{tabular}
\end{center}
\end{table}

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
\hspace{0.6cm}В данном разделе были рассмотрены примеры работы стандартного алгоритма, алгоритма Кнута-Морриса-Пратта и  алгоритма Бойера-Мура на конкретной строке и подстроке.

\chapter{Технологическая часть}
\hspace{0.6cm}В данном разделе приведены требования к программному обеспечению, средства реализации и листинги кода
\section{Требования к ПО}

\hspace{0.6cm}Программа на вход получает строку и искомую подстроку. Выход  программы: индекс первого вхождения подстроки либо -1 в случае ее невхождения в строку.
	
\section{Средства реализации}
\hspace{0.6cm}Для реализации представленных алгоритмов был выбран язык C++. Время работы алгоритмов было замерено с помощью функции high\_resolution\_clock() из библиотеки chrono. Для тестирования использовался компьютер на базе процессора Intel Core i5 (4 физических ядра, 8 логических).

\section{Листинги кода}

В листинге 3.1 показана реализация стандартного алгоритма.

\begin{lstlisting}[caption=Функция стандартного алгоритма]
    int standartSearch(const std::string &text, const std::string &substring)
    {
        for (int i = 0; i <= text.length() - substring.length(); i++)
        {
            bool found = true;
            for (int j = 0; j < substring.length() && found; j++)
            {
                if (text[i + j] != substring[j])
                {
                    found = false;
                }
            }
            if (found)
            {
                return i;
            }
        }
        return -1;
    }
\end{lstlisting}

В листингах 3.2 представлена реализация алгоритма Кнута-Морриса-Пратта.
\begin{lstlisting}[caption=Главная функция алгоритма Кнута-Морриса-Пратта]
    int searchKMP(const std::string &text, const std::string &substring)
    {
        std::vector<int> prefix = getPrefix(substring);
        int last = 0;
        for (int i = 0; i < text.length(); i++)
        {
            while (last > 0 && substring[last] != text[i])
                last = prefix[last - 1];
    
            if (substring[last] == text[i])
                last++;
    
            if (last == substring.length())
            {
                return i + 1 - substring.length();
            }
        }
        return -1;
    }
\end{lstlisting}

 Основная функция вызывает функцию поиска массива префиксов, представленную в листинге 3.3.

\begin{lstlisting}[caption=Функция вычисления массива префиксов]
    std::vector<int> getPrefix(const std::string &substring)
    {
        std::vector<int> prefix(substring.length());
        prefix[0] = 0;
        for (int i = 1; i < substring.length(); i++)
        {
            int last = prefix[i-1];
            while (last > 0 && substring[last] != substring[i])
                last = prefix[last - 1];
    
            if (substring[last] == substring[i])
                last++;
    
            prefix[i] = last;
        }
        return prefix;
    }
\end{lstlisting}

В листинге 3.4 представлена реализация алгоритма Бойера-Мура.

\begin{lstlisting}[caption=Главная функция алгоритма Бойера-Мура]
    int searchBM(const std::string &text, const std::string &substring)
    {
        std::unordered_map<char, int> stopTable;
        int m = substring.length();
        int n = text.length();
        std::vector<int> suffix = getSuffix(substring);
        for (int i = 0; i < m; ++i)
        {
            stopTable[substring[i]] = m - 1 - i;
        }
    
        for (int i = m - 1; i < n;)
        {
            int j = m - 1;
    
            while (substring[j] == text[i])
            {
                if (j == 0) return i;
                i--;
                j--;
            }
            auto stop_symbol = stopTable.find(text[i]);
            int stopAdd = stop_symbol != stopTable.end() ? stop_symbol->second : m;
            i += std::max(suffix[m - j - 1], stopAdd);
        }
    
        return -1;
    }
\end{lstlisting}

Основная функция вызывает функцию поиска массива суффиксов, представленную в листинге 3.5.

\begin{lstlisting}[caption=Функция вычисления массива суффиксов]
    std::vector<int> getSuffix(const std::string &substring)
    {
        int n = substring.length();
        std::vector<int> table(n);
        int lastPrefixPosition = n;
    
        for (int i = n - 1; i >= 0; i--)
        {
            if (isPrefix(substring, i + 1))
                lastPrefixPosition = i + 1;
            table[n - 1 - i] = lastPrefixPosition - i + n - 1;
        }
    
        for (int i = 0; i < n - 1; i++)
        {
            int slen = suffixLength(substring, i);
            table[slen] = n - 1 - i + slen;
        }
    
        return table;
    }
\end{lstlisting}

\section{Вывод}
\hspace{0.6cm}Были реализованы стандартный алгоритм, алгоритм Бойера-Мура и алгоритм Кнута-Морриса-Пратта, решающие задачу поиска подстроки в строке.

\chapter{Экспериментальная часть}
\hspace{0.6cm}В данном разделе сравнительный анализ алгоритмов поиска подстроки в строке.

\section{Сравнение временных характристик}
\hspace{0.6cm}Для сравнения стандартного алгоритма, алгоритма Бойера-Мура и алгоритма Кнута-Морриса-Пратта строки и подстроки генерировались случайным образом. Длина подстроки была фиксирована и равнялась 3, а размер строки менялся от 1000 до 100000 с шагом в 1000 символов. На рисунке 4.1 представлен график зависимости времени работы каждого из реализованных алгоритмов от размера строки.

\begin{figure}[ht!]
\begin{center}
\begin{tikzpicture}[scale = 1]
\begin{axis}[
    	axis lines = left,
    	xlabel = {Размерность строки},
    	ylabel = {Время(миллисекунды)},
	legend pos=north west,
	ymajorgrids=true,
	width = 350,
	height = 250
]
\addplot[color=blue] table[x index=0, y index=1] {Standart.dat}; 
\addplot[color=green] table[x index=0, y index=1] {KMP.dat};
\addplot[color=orange] table[x index=0, y index=1] {BM.dat};
\addlegendentry{Стандартный}
\addlegendentry{Кнута-Морриса-Пратта}
\addlegendentry{Бойера-Мура }
\end{axis}
\end{tikzpicture}
\caption{Алгоритмы решения задачи поиска подстроки в строке}
\end{center}
\end{figure}

Как можно наблюдать на графике, алгоритм Бойера-Мура показывает лучшие результаты, время его работы практически перестает расти на размерах строк более 60000 символов. Алгоритм Кнута-Морриса-Пратта проигрывает стандартному во времени до строк размеров $\approx$ 75000 символов, после этого он становится эффективнее стандартного.
\section{Вывод}
\hspace{0.6cm}В результате проведенных экспериментов был выявлен оптимальный для использования алгоритм, который показывает наименьшее время работы на любых размерах строк - алгоритм Бойера-Мура.

\newpage

\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}
\hspace{0.6cm}В ходе работы были изучены и реализованы основные алгоритмы для решения задачи поиска подстроки в строке: стандартный алгоритм, алгоритм Бойера-Мура и алгоритм Кнута-Морриса-Пратта. Был проведен их сравнительный анализ, в ходе которого были получены зависимости времени выполнения алгоритмов от размеров входной строки. В результате экспериментов было получено, что алгоритм алгоритм Бойера-Мура работает одинаково быстро на всех размерах строк, время его работы практически перестает расти при размрах строк более 60000 символов, и он является оптимальным алгоритмом для решения поставленной задачи.
  
\end{document}